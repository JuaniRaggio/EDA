# Estructura de Datos y Algoritmos

# ITBA     2025-Q2

# BST

Operaciones sobre un BST

__2\)  Borrar:  no basta con eliminar un elemento\, se debe mantener la forma del original \(no deformarse\)__

__El algoritmo es el siguiente:__

__R1__ : Si el nodo a eliminar es hoja\, actualizar quien lo apunta a él \(puntero a raíz o su antecesor inmediato\) para que ya no lo apunte más a él y pase a apuntar a NULL\.

__R2__ : Si el nodo a eliminar tiene un solo hijo\, actualizar quien lo apunta a él \(puntero a raíz o su antecesor inmediato\) para que en vez de apuntarlo a él lo haga al hijo del que se borra\.

__R3__ : Si el nodo a eliminar tiene dos hijos se procede en dos pasos: primero se lo  __reemplaza__  por un  _nodo lexicográficamente adyacente_  \(su  _predecesor  inorder_  o sea el más grande de los nodos de su subárbol izquierdo\, o bien su  _sucesor inorder_  o sea el más chico de los nodos de su subárbol derecho\)\, y finalmente se borra al nodo que lo reemplazó \(seguro que dicho nodo tiene a lo sumo un solo hijo\, sino no sería el lexicográficamente adyacente\, y por lo tanto es fácil de borrar\)

Ej: Se quiere borrar el 80  \(R1\)

![](img/19-B%281%29_0.png)

![](img/19-B%281%29_1.png)

A partir de lo obtenido se quiere borrar 10  \(R2\)

![](img/19-B%281%29_2.png)

![](img/19-B%281%29_3.png)

A partir de lo obtenido se quiere borrar 70  \(R3\)\. Supongamos que usamos su predecessor inorder

![](img/19-B%281%29_4.png)

![](img/19-B%281%29_5.png)

__A partir del siguiente BST\, mostrar gráficamente cómo queda paso a paso el BST luego de aplicar las siguientes operaciones y qué reglas se usaron\. __

__Usar predecesor inorder:  40\, 35 y 8 \(en ese orden\)__

# TP 5C – Ejer 6.1

![](img/19-B%281%29_6.png)

Borrar 40

Borrar 35

Borrar 8

__Implementar el borrado según lo explicado__

![](img/19-B%281%29_7.png)

_Ejercicio 8\.2_

_	_ El borrado puede implementarse en forma recursiva

_En BST_

![](img/19-B%281%29_8.png)

En Node

![](img/19-B%281%29_9.png)

![](img/19-B%281%29_10.png)

Hacer un seguimiento de su funcionamiento\. Implementarlo y testearlo

__Cambiar la interface BSTreeInterface para que sea iterable__

# TP 5C – Ejer 7.1

![](img/19-B%281%29_11.png)

# BST

Para ello corresponde que la interfaz BSTreeInterface extienda a Iterable\.

El iterador devolverá los  __elementos por niveles__ \, como lo hicimos previamente\.

No asumir que pueden generar de un BST su información en una estructura auxiliar completamente\. Tratar de “recorrer en el momento” o con algún element forward\.

__Caso de Uso: __

BST\<Integer> myTree = new BST<>\(\);

myTree\.insert\(35\);

myTree\.insert\(74\);

myTree\.insert\(20\);

myTree\.insert\(22\);

myTree\.insert\(55\);

myTree\.insert\(15\);

myTree\.insert\(8\);

myTree\.insert\(27\);

myTree\.insert\(25\);

__for \(Integer data : myTree\) \{__

__    System\.out\.print\(data \+  " "\);__

__\} __

// Puedo hacerlo múltiples veces…

System\.out\.println\("\\n\\nUna vez más…\\n"\);

__myTree\.forEach\( t\-> System\.out\.print\(t \+ " "\) \);__

__35   20   74   15   22   55   8   27   25 __

__Una vez más__

__35   20   74   15   22   55   8   27   25 __

Tip: tomar la versión \(iterativa\) y transformarla\.

![](img/19-B%281%29_12.png)

![](img/19-B%281%29_13.png)

__Hacer que el iterador lo haga inOrder\.__

__Para ello\, conviene escribir el método inOrder en format no recursivo\.__

# TP 5C – Ejer 7.2

![](img/19-B%281%29_14.png)

![](img/19-B%281%29_15.png)

__Caso de Uso: __

BST\<Integer> myTree = new BST<>\(\);

myTree\.insert\(35\);

myTree\.insert\(74\);

myTree\.insert\(20\);

myTree\.insert\(22\);

myTree\.insert\(55\);

myTree\.insert\(15\);

myTree\.insert\(8\);

myTree\.insert\(27\);

myTree\.insert\(25\);

__for \(Integer data : myTree\) \{__

__    System\.out\.print\(data \+  " "\);__

__\} __

// Puedo hacerlo múltiples veces…

System\.out\.println\("\\n\\nUna vez más…\\n"\);

__myTree\.forEach\( t\-> System\.out\.print\(t \+ " "\) \);__

__debería obtenerse__

__8 15 20 22 25 27 35 55 74__

__Una vez más__

__8 15 20 22 25 27 35 55 74  __

![](img/19-B%281%29_16.png)

![](img/19-B%281%29_17.png)

__Dejar que el usuario elija el iterador que desea\, tantas veces lo quiera__

![](img/19-B%281%29_18.png)

# BST

El problema es que no se puede cambiar el método iterator\(\) parametrizandolo por la forma en que se lo quiere recorrer\.

@Override

__public Iterator\<T> __  <span style="color:#ff0000"> __iterator\( ?? \) __ </span>  __\{__

__  …__

\}

Posible solución:

Agregar un método que hay que invocar “antes” de tomar el iterador que indique de qué manera se lo quiere recorrer\. El default\, de no invocarse\, es iteración byLevels\.

Chequearlo con múltiples invocaciones de formas de recorrido\!\!\!

Básicamente:

Sacar comentario en la interface…

__public interface BSTreeInterface\<T extends Comparable<? super T>> \.\.\.\{__

_  enum Traversal \{ _  _BYLEVELS\, INORDER_  _\}_

_  void setTraversal\(Traversal traversal\);_

__  …__

__\}__

# Caso de uso A

__public static void main\(String\[\] args\) \{__

BST\<Integer>  myTree=  __new BST<>\(\);__

myTree\.insert\(35\);   myTree\.insert\(74\);

myTree\.insert\(20\);   myTree\.insert\(22\);

myTree\.insert\(55\);   myTree\.insert\(15\);

myTree\.insert\(8\);     myTree\.insert\(27\);

myTree\.insert\(25\);

<span style="color:#0070c0">System\.</span>  <span style="color:#0070c0"> _out\.println\("\\n\\nDefault Traversal…\\n"\);_ </span>

<span style="color:#0070c0">myTree\.forEach\( t\-> System\.</span>  <span style="color:#0070c0"> _out\.print\(t \+ " "\) \);_ </span>

<span style="color:#7030a0">myTree\.setTraversal\(Traversal\.</span>  <span style="color:#7030a0"> _INORDER\);_ </span>

<span style="color:#7030a0">System\.</span>  <span style="color:#7030a0"> _out\.println\("\\n\\nUna vez más INORDER\\n"\);_ </span>

<span style="color:#7030a0">myTree\.forEach\( t\-> System\.</span>  <span style="color:#7030a0"> _out\.print\(t \+ " "\) \);_ </span>

<span style="color:#0070c0">myTree\.setTraversal\(Traversal\.</span>  <span style="color:#0070c0"> _BYLEVELS\);_ </span>

<span style="color:#0070c0">System\.</span>  <span style="color:#0070c0"> _out\.println\("\\n\\nUna vez más BYLEVELS\\n"\);_ </span>

<span style="color:#0070c0">myTree\.forEach\( t\-> System\.</span>  <span style="color:#0070c0"> _out\.print\(t \+ " "\) \);_ </span>

<span style="color:#7030a0">myTree\.setTraversal\(Traversal\.</span>  <span style="color:#7030a0"> _INORDER\);_ </span>

<span style="color:#7030a0">System\.</span>  <span style="color:#7030a0"> _out\.println\("\\n\\nUna vez más INORDER\\n"\);_ </span>

<span style="color:#7030a0">myTree\.forEach\( t\-> System\.</span>  <span style="color:#7030a0"> _out\.print\(t \+ " "\) \);_ </span>

\}

__Default Traversal__

__35   20   74   15   22   55   8   27   25 __

__Una vez más INORDER__

__8   15   20   22   25   27   35   55   74 __

__Una vez más BYLEVELS__

__35   20   74   15   22   55   8   27   25 __

__Una vez más INORDER__

__8   15   20   22  25   27   35   55   74 __

Posible Implementación

![](img/19-B%281%29_19.png)

