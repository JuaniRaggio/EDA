# Estructura de Datos y Algoritmos

# ITBA     2025-Q2

__Implementar el iterador read\-only\.__

__Agregar a la interface:__

__public interface SortedListService\<T extends Comparable<? super T>> __  <span style="color:#ff0000"> __extends Iterable\<T> __ </span>

# TP 3C- Ejer 3

Caso de Uso:

SortedListService\<String> l =

new SortedLinkedList<>\(\);

l\.add\(“hola”\);  l\.add\(“tal”\);  l\.add\(“que”\);

__for \(String s : l\) \{__

System\. _out\.println\(s\);_

\}

Iterable\<T>

hay que implementar:

__public Iterator\<T> iterator\(\)__

Iterator\<T>

hay que implementar:

__public boolean hasNext\(\)__

__public T next\(\)__

Caso de Uso From Scratch:

SortedListService\<String> l =

new SortedLinkedList<>\(\);

l\.add\(“hola”\);  l\.add\(“tal”\);  l\.add\(“que”\);

__for\( Iterator\<String> it = l\.iterator\(\); it\.hasNext\(\); \) \{__

__	System\.out\.println\( it\.next\(\) \);__

__\}__

Posible solución:

@Override

__public Iterator\<T> iterator\(\) \{__

__return new SortedLinkedListIterator\(\) \{__

\};

\}

__private class SortedLinkedListIterator implements Iterator\<T> \{__

__private Node current;__

__public SortedLinkedListIterator\(\) \{__

current= root;   \}

@Override

__public boolean hasNext\(\) \{__

__     return current \!= null;  __ \}

@Override

__public T next\(\) \{__

__    if \(\!hasNext\(\)\) \{__

__       throw new NoSuchElementException\(\);__

\}

T rta= current\.data;

current= current\.next;

__  return rta;__

\}

\}

__Que complejidad temporal tienen:__

__getMin\(\)__

__getMax\(\)__

__size\(\)__

Algunas de esas operaciones podría bajar su complejidad\, a expensas de un poco más de información

Sería interesante evitar “recorrer la lista” para saber su tamaño\.

Guardalo en informacion “global” a la lista\. \.

Analicemos otra variante de Lista Lineal Simplemente Encadenada\.

# Analizando otras alternativas

Alternativa: “ <span style="color:#00b050"> __Lista lineal simplemente encadenada con header__ </span> ”

Header: $2222”

<span style="color:#00b050">Definición Lista Lineal Simplemente Encadenada con Header</span>

Es una estructura de datos compuesta por:

Un elemento distinguido llamado “header” que tiene la referencia del primer elemento de la lista  <span style="color:#00b050"> __y además  información global de la lista\.__ </span>

Cada nodo/elemento \(común\) almacena 2 cosas: su info y la referencia al elemento siguiente\.

Alternativa: “ <span style="color:#00b050"> __Lista lineal simplemente encadenada con header__ </span> ”

Header: $2222”

<span style="color:#00b050">Variante para Índice</span>

<span style="color:#00b050">Definición Lista Lineal Simplemente Encadenada </span>  <span style="color:#00b050"> __Ordenada__ </span>  <span style="color:#00b050"> con Header</span>

Es una lista lineal simplemente encadenada con header que además mantiene los  __elementos ordenados__  con algún criterio de ordenación\.

Es decir\,

Hay 2 tipos de nodos: header y comunes\.

_El nodo header no tiene que ser comparable_ \. Hay uno solo de ese tipo de nodo\!\!\!

Los nodos comunes tienen que poder compararse entre sí\.

__Implementar la clase __  __SortedLinkedListWithHeader \(implementa misma interface\) __  __donde:__

__getMin\(\)\, getMax\(\)\, size\(\)__

__Resuelvan en O\(1\)__

# TP 3C- Ejer 5

