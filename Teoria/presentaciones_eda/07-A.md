# Estructura de Datos y Algoritmos

# ITBA     2025-Q2

_API para las queries_

_1\.1 	TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

<span style="color:#00b050"> _1\.3 	TermRangeQuery: busca por rangos_ </span>

1\.4 	PhraseQuery: busca secuencia

1\.5 	 WildcardQuery

1\.6 	FuzzyQuery // Damerau\-Levenshtein con MaxEdit 2

1\.7 	BooleanQuery

_Etc\.\, etc\.\,  etc\._

TermRangeQuery  buscar si el “término” se encuentra en el intervalo especificado\. El mismo puede ser abierto/cerrado a izq\, abierto/cerrado a derecha:

<span style="color:#00b050">\[</span> BytesRefIzq\, BytesRefDer <span style="color:#00b050">\]</span> :

fieldName\,  BytesRefIzq\, BytesRefDer\,  <span style="color:#00b050">true</span> \,  <span style="color:#00b050">true</span>

<span style="color:#ff9900">\(</span> BytesRefIzq\, BytesRefDer <span style="color:#ff9900">\)</span> :

fieldName\,  BytesRefIzq\, BytesRefDer\,  <span style="color:#ff9900">false</span> \,  <span style="color:#ff9900">false</span>

<span style="color:#00b050">\[</span> BytesRefIzq\, BytesRefDer <span style="color:#ff9900">\)</span> :

fieldName\,  BytesRefIzq\, BytesRefDer\,  <span style="color:#00b050">true</span> \,  <span style="color:#ff9900">false</span>

<span style="color:#ff9900">\(</span> BytesRefIzq\, BytesRefDer <span style="color:#00b050">\]</span> :

fieldName\,  BytesRefIzq\, BytesRefDer\,  <span style="color:#ffc000">false</span> \,  <span style="color:#00b050">true</span>

# TP 2-C Ejer 3.3

__Query__  __ __  __query__  __= __

__new __  __TermRangeQuery__  __\(__  __fieldName__  __\, __  __BytesRefIzq__  __\, __  __BytesRefDer__  __\, __  __boolean__  __\, __  __boolean__  __ __  __\);__

__Or__

__Query__  __ __  __query__  __ = __  __TermRangeQuery\.newStringRange__  __\( __  __fieldName__  __\, __

__String__  __\, __  __String__  __\, __  __boolean__  __\, __  __booleab__  __ __  __\);__

# =>TermRangeQuery

![](img/07-A_0.png)

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado

Query query=  __new __  __TermRan;geQuery__  __\(__  __fieldName__  __\, __ BytesRefIzq\, BytesRefDer\,  <span style="color:#00b050">boolean</span> \,  <span style="color:#00b050">boolean</span>  <span style="color:#00b050">\);</span>

donde los  <span style="color:#00b050">BytesRef</span>  <span style="color:#00b050"> </span>  __se obtienen __  <span style="color:#00b050">con new </span>  <span style="color:#00b050">BytesRef</span>  <span style="color:#00b050">\(“</span>  <span style="color:#00b050">string</span>  <span style="color:#00b050">"\) </span> del campo  __content__

Como alternativa:

Query q = TermRangeQuery\.newStringRange\( fieldName\, stringFrom\, stringTo\,  <span style="color:#00b050">boolean</span>  <span style="color:#00b050">\, </span>  <span style="color:#00b050">boolean</span>  \);

\[“gam”\, “gum”\]

\[“game”\, “game” \]   // equivalente a ????

\[“game”\, “game”\)

\[“gum”\, “gam”\]

\(“game”\, “gum”\]

\(“gaming”\, “gum”\)

_API para las queries_

_1\.1 	TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

_1\.3 	TermRangeQuery: busca por rangos_

<span style="color:#00b050"> _1\.4 	PhraseQuery: busca secuencia_ </span>

1\.5 	 WildcardQuery

1\.6 	FuzzyQuery // Damerau\-Levenshtein con MaxEdit 2

1\.7 	BooleanQuery

_Etc\.\, etc\.\,  etc\._

# TP 2-C Ejer 3.4

__Query query= __  __new PhraseQuery\(fieldName\, word1\, word2\, … wordN \);__

# =>PhraseQuery

![](img/07-A_1.png)

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado

Query query=  __new PhraseQuery\(fieldName\, word1\, word2\, … wordN \);  __

__si busco la frase: word1  word2   wordN__

Donde los casos a probar son:

Frase:  “store”  “game”

Frase:  “store\,\,”  “game”

Frase: “game” “store”

Frase: “store game”

Frase: “store\,\, game”

Frase: “game”  “review”

Frase: “game”  “video”  “game”

Frase: “game”  “video”  “review”

Pregunta:

Qué información del índice le permite a Lucene responder a las consultas por PhraseQuery?

API para las queries

1\.1 	 _TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

_1\.3 	TermRangeQuery: busca por rangos_

_1\.4 _  <span style="color:#00b050"> _	_ </span>  _PhraseQuery: busca secuencia_

<span style="color:#00b050"> _1\.5 	 WildcardQuery: busca por matching de \* o bien ?_ </span>

1\.6 	FuzzyQuery: Damerau\-Levenshtein con MaxEdit 2

1\.7 	BooleanQuery

Etc\.\, etc\.\,  etc\.

# TP 2-C Ejer 3.5

__Query query= __  __new WildcardQuery\(myTerm\);__

# =>WildcardQuery

![](img/07-A_2.png)

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado

Query query=  __new WildcardQuery\(myTerm\) __

Donde los casos a probar son:

queryStr= “g\*e”

queryStr= “g?me”

queryStr= “g?m”

queryStr= “G??e”

queryStr= “\*”

__\*__  __ representa cualquier secuencia de caracteres inclusive vacío__

__?__  __ representa un caracter cualquiera__

API para las queries

_1\.1 	TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

_1\.3 	TermRangeQuery: busca por rangos_

_1\.4 _  <span style="color:#00b050"> _	_ </span>  _PhraseQuery: busca secuencia_

_1\.5 	 WildcardQuery_

<span style="color:#00b050"> _1\.6 	FuzzyQuery: Damerau\-Levenshtein con MaxEdit 2_ </span>

1\.7 	BooleanQuery

Etc\.\, etc\.\,  etc\.

# TP 2-C Ejer 3.6

__Query query= __  __new FuzzyQuery\(myTerm \);  __

# =>FuzzyQuery

![](img/07-A_3.png)

Pregunta:

MaxEdit es operaciones\, no similitud \(no está normalizado\)\.

¿Qué información del índice le permite a Lucene responder a las consultas por FuzzyQuery?

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado\.

Query query=  __new FuzzyQuery\(myTerm \);  __

Donde los casos a probar son:

queryStr= “gno”

queryStr= “gem”

queryStr= “agem”

queryStr= “hm”

queryStr= “ham”

API para las queries

_1\.1 	TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

_1\.3 	TermRangeQuery: busca por rangos_

_1\.4 _  <span style="color:#00b050"> _	_ </span>  _PhraseQuery: busca secuencia_

_1\.5 	 WildcardQuery_

_1\.6 	_  __FuzzyQuery: Damerau\-Levenshtein con MaxEdit 2__

<span style="color:#00b050">1\.7 	BooleanQuery</span>

Etc\.\, etc\.\,  etc\.

Las consultas no siempre son tan puntuales…

Muchas veces se necesita combinar esas características\. Inclusive entre varios campos…

Ej:  que cierta frase aparezca en el campo “content” pero que no aparezca tal término\.

Ej:  que cierta frase aparezca en el campo “content” y también tal término parezca en otro campo\.

Ej:  que empiece con tal prefijo en el campo “content” o bien se parezca en otro campo indexado\.

Sin duda\,  <span style="color:#00b050"> _BooleanQuery_ </span>  parece resolver este problema\.

Pero con API es tedioso usarlo porque hay que combinar varios constructores \(para el AND\, para el OR\, para el NOT\)\.

En vez de analizar BooleanQuery vamos a conocer la otra forma que tiene Lucene de realizar consultas sin API: QueryBuilder\!

# Lucene



* <span style="color:#00b050"> _Concepto de documento\, campos\._ </span>
* <span style="color:#00b050"> _Almacenamiento en Lucene: en el índice y fuera del índice_ </span>
* <span style="color:#00b050"> _Aplicaciones_ </span>
  * <span style="color:#00b050"> _IndexBuilder  \(creación de los documentos\)_ </span>
  * <span style="color:#00b050"> _TheSearcher \(búsqueda de documentos\)_ </span>
* <span style="color:#00b050"> _Query:_ </span>
  * <span style="color:#00b050"> _API_ </span>
  * <span style="color:#00b050">QueryBuilder</span>
* Formas de separar en tokens
* Ranking de documentos


2\.	QueryBuilder para las queries

Lucene  __define un lenguaje de consulta y __ él se encarga de parsearlo y transformarlo en varias invocaciones de APIs \(las mismas que vimos antes\)\.

Resulta muy práctico\, pero para poder usarlo debemos conocer dicho lenguaje\. Si no lo respetamos\, obtenemos error en tiempo de ejecución en el parser\.

Mostraremos cada una de las invocaciones anteriores como sería con el QueryParser\.

| API | QueryBuilder |
| :-: | :-: |
| 1\.1TermQuery | fieldName:termino |
| 1\.2 PrefixQuery | fieldName:term <span style="color:#00b050">\*</span> |
| 1\.3 TermRangeQuery | fieldName: <span style="color:#00b050">\{\[</span> start   <span style="color:#00b050">TO</span>   end <span style="color:#00b050">\]\}</span> |
| 1\.4 PhraseQuery | fieldName: <span style="color:#00b050">“</span> term1 \.\.\. termN <span style="color:#00b050">”</span> |
| 1\.5 WildcardQuery | fieldName: <span style="color:#00b050">\*</span> subterm <span style="color:#00b050">?</span> |
| 1\.6 FuzzyQuery | fieldName:termino <span style="color:#00b050">~2</span> |
| 1\.7 BooleanQuery | <span style="color:#00b050">AND  OR  </span>  <span style="color:#00b050">NOT</span> |

Pregunta:

Cuando con API preguntamos por TermQuery por “Game”\, ¿lo encontró? ¿Por qué?

Rta

Porque para ingresar al índice le hemos aplicado un StandardAnalizer\(\) que detectó tokens por espacios y símbolos de puntuación y además los insertó en minúsculas\.

Si la query no es igual\, no lo va a encontrar\.

Y mejor aún si usamos algún Analyzer \(como usamos en la construcción del índice\) para que pase a minúsculas\, elimine stopwords en la propia query

QueryParser qp = new QueryParser\(null\,  __new StandardAnalyzer\(\)__ \);

Antes de comenzar a usar el QueryParser\, veamos con los tipos de separación en tokens que pueden usarse…



* <span style="color:#00b050"> _Concepto de documento\, campos\._ </span>
* <span style="color:#00b050"> _Almacenamiento en Lucene: en el índice y fuera del índice_ </span>
* <span style="color:#00b050"> _Aplicaciones_ </span>
  * <span style="color:#00b050"> _IndexBuilder  \(creación de los documentos\)_ </span>
  * <span style="color:#00b050"> _TheSearcher \(búsqueda de documentos\)_ </span>
* <span style="color:#00b050"> _Query:_ </span>
  * <span style="color:#00b050"> _API_ </span>
  * <span style="color:#00b050"> _QueryBuilder_ </span>
* <span style="color:#00b050">Formas de separar en tokens</span>
* Ranking de documentos


Hemos usado StandardAnalyzer en la creación del índice\.

¿Qué otro analyzer podríamos usar?

¿Cómo afecta el índice y la búsqueda?



* Lucene viene con diferentes clases para separar en tokens:
* SimpleAnalyzer\(\)
* StandardAnalyzer\(\)
* WhitespaceAnalyzer\(\)
* StopAnalyzer\(\)=>
  * CharArraySet sw = StopFilter\. _makeStopSet\("de"\, "y"\);_
  * new StopAnalyzer\(sw\)\);
* EnglishAnalyzer\(\)  // opcional stop words
* SpanishAnalyzer\(\)  // opcional stop words\.
* CustomAnalyzer\(\)
* etc


__Bajar de Campus el código TestAnalyzer\.java __

__Explicamos a continuación cómo se usa\.__

# TP 2C- Ejer 4

El código sirve para ver cómo hace Lucene por dentro \(para inspeccionar la separación en tokens\)\. Como verán\, no estamos creando documentos\, solo usando un Low Level API para ver qué tokens genera\.

Probar cuáles son lo tokens que genera en cada caso\.

![](img/07-A_4.png)

![](img/07-A_5.png)

Pregunta:

Qué hizo SpanishAnalyzer?

Rta: busco la raíz de las palabras “stemmer algorithm”\.

C\.J\. van Rijsbergen\, S\.E\. Robertson and M\.F\. Porter\, 1980 en “ _New models in probabilistic information retrieval” propusieron un algortimo para encontrar la raíz de las palabras en idioma ingles\._

_Así los IR engine guardan menos letras y matchean más\._

_Si tienen curiosidad por el algoritmo en diferentes idiomas_

_[https://snowballstem\.org/algorithms/](https://snowballstem.org/algorithms/)_

Para usar el

CustomAnalyzer:

Analyzer analyzer = CustomAnalyzer\.builder\(\)

\.withTokenizer\("standard"\)

\.addTokenFilter\("lowercase"\)

\.addTokenFilter\("stop"\)

\.addTokenFilter\("porterstem"\)

\.build\(\);

__Vamos resolver las consultas con un __

__StandardAnalyer__  __ __  __\(para __  __tokenizar__  __ el __  __query__  __\)__

__Y un __

__QueryParser__  __ __

__Así\, ya no tenemos que invocar diferentes subclases…__

![](img/07-A_6.png)

Para rehacer las queries hechas previamente con  <span style="color:#ff0000"> __QueryParser__ </span>  <span style="color:#ff0000">\,</span>  incorporar \(desde Campus\)  <span style="color:#00b050"> __TheSearcherQueryParser\.java__ </span>  __\.__

En QueryString hay que colocar la query en el Lenguaje Explicado\.

__\<dependency>__

__    \<groupId>org\.apache\.lucene\</groupId>__

__    \<artifactId>lucene\-queryparser\</artifactId>__

__    \<version>7\.4\.0\</version>__

__\</dependency>__

_Rehacer las queries realizadas con API por medio de QueryParser_

<span style="color:#00b050"> _1\.1 	TermQuery: busca un solo término_ </span>

1\.2 	PrefixQuery: busca por prefijo

1\.3 	TermRangeQuery: busca por rangos

1\.4 	PhraseQuery

1\.5 	 WildcardQuery

1\.6 	FuzzyQuery // Damerau\-Levenshtein con MaxEdit 2

1\.7 	BooleanQuery

_Etc\.\, etc\.\,  etc\._

| API | QueryParser |
| :-: | :-: |
| __queryStr=__  __“game”__  __;__  __Term myTerm = new Term\(__  __“content”__  __\, queryStr\);__  __ Query query= new TermQuery\(myTerm \)__ | queryStr=" __content:__  <span style="color:#ff0000">game</span> "; __Query__  __ __  __query__  __= __  __queryparser\.parse__  __\(__  __queryStr__  __\);__ |

Ejercicio 5\.1

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado\, __ __  __donde los casos a probar son __  __los términos:__

| Valor | FieldName | El query se escribe así |
| :-: | :-: | :-: |
| <span style="color:#ff0000"> __game__ </span> | content |  |
| <span style="color:#ff0000"> __Game__ </span> | content |  |
| <span style="color:#ff0000"> __ga__ </span> | content |  |
| <span style="color:#ff0000"> __game__ </span>  <span style="color:#ff0000"> __\,\,__ </span> | content |  |

_API para las queries_

_1\.1 	TermQuery: busca un solo término_

_1\.2 	_  <span style="color:#00b050"> _PrefixQuery: busca por prefijo_ </span>

1\.3 	TermRangeQuery: busca por rangos

1\.4 	PhraseQuery: busca secuencia

1\.5 	 WildcardQuery

1\.6 	FuzzyQuery // Damerau\-Levenshtein con MaxEdit 2

1\.7 	BooleanQuery

_Etc\.\, etc\.\,  etc\._

| API | QueryParser |
| :-: | :-: |
| __queryStr__  __=__  __“__  __ga__  __”__  __;__  __Term__  __ __  __myTerm__  __ = new __  __Term__  __\(__  __“__  __content__  __”__  __\, __ queryStr __\);__  __ __  __Query__  __ __  __query__  __= new __  __PrefixQuery__  __\(__  __myTerm__  __ \)__ | queryStr=" __content:__  <span style="color:#ff0000">ga</span>  <span style="color:#ff0000">\*</span> "; __Query__  __ __  __query__  __= __  __queryparser\.parse__  __\(__  __queryStr__  __\);__ |

Ejercicio 5\.2

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado\,  __donde __  __los casos a probar __  __son los prefijos:__

| Valor | FieldName | El query se escribe así |
| :-: | :-: | :-: |
| <span style="color:#ff0000"> __game__ </span>  <span style="color:#ff0000"> __ __ </span> | content |  |
| <span style="color:#ff0000"> __ga__ </span> | content |  |
| <span style="color:#ff0000"> __Ga__ </span> | content |  |
| <span style="color:#ff0000"> __me__ </span> | content |  |

_API para las queries_

_1\.1 	TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

<span style="color:#00b050"> _1\.3 	TermRangeQuery: busca por rangos_ </span>

1\.4 	PhraseQuery: busca secuencia

1\.5 	 WildcardQuery

1\.6 	FuzzyQuery // Damerau\-Levenshtein con MaxEdit 2

1\.7 	BooleanQuery

_Etc\.\, etc\.\,  etc\._

| API | QueryParser |
| :-: | :-: |
| __Query__  __ __  __query__  __ = __  __TermRangeQuery\.newStringRange__  __\(__  __"__  __content__  __"\, "__  __gaming__  __"\, "__  __gum__  __"\, false\, true \);__ | queryStr=" __content__  __:__  <span style="color:#ff0000">\{</span>  <span style="color:#ff0000">gaming</span>  <span style="color:#ff0000"> TO </span>  <span style="color:#ff0000">gum</span>  <span style="color:#ff0000">\]</span> "; __Query__  __ __  __query__  __= __  __queryparser\.parse__  __\(__  __queryStr__  __\);__ |

Ejercicio 5\.3

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado\, si se busca los siguientes intervalos:

Intervalo cerrado   <span style="color:#ff0000">gam</span>       <span style="color:#ff0000">gum</span>

Intervalo cerrado   <span style="color:#ff0000">game</span>      <span style="color:#ff0000">game</span>

Intervalo cerrado izq  y abierto der   <span style="color:#ff0000">game</span>      <span style="color:#ff0000">game</span>

Intervalo cerrado   <span style="color:#ff0000">gum</span>  <span style="color:#ff0000">      </span>  <span style="color:#ff0000">gam</span>

Intervalo abierto izq  y cerrado der   <span style="color:#ff0000">game</span>      <span style="color:#ff0000">gum</span>  <span style="color:#ff0000"> </span>

Intervalo abierto   <span style="color:#ff0000">gaming</span>     <span style="color:#ff0000">gum</span>

_API para las queries_

_1\.1 	TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

_1\.3 	TermRangeQuery: busca por rangos_

<span style="color:#00b050"> _1\.4 	PhraseQuery: busca secuencia_ </span>

1\.5 	 WildcardQuery

1\.6 	FuzzyQuery // Damerau\-Levenshtein con MaxEdit 2

1\.7 	BooleanQuery

_Etc\.\, etc\.\,  etc\._

| API | QueryParser |
| :-: | :-: |
| __Query__  __ __  __query__  __= __  __new __  __PhraseQuery__  __\(“__  __content__  __”\, __  __“store”\, “__  __game__  __”__  __\)__ | queryStr=" __content__  __:__  <span style="color:#00b050">\\”</span>  <span style="color:#ff0000"> __store __ </span>  <span style="color:#ff0000"> __game__ </span>  <span style="color:#00b050">\\"</span> "; __Query__  __ __  __query__  __= __  __queryparser\.parse__  __\(__  __queryStr__  __\);__ |

Ejercicio 5\.4

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado

| Valor \(cada token en ese orden\) |  |  |  | FieldName | El query se esribe así |
| :-: | :-: | :-: | :-: | :-: | :-: |
| <span style="color:#ff0000"> __store__ </span> |  | <span style="color:#ff0000"> __game__ </span> |  | content |  |
| <span style="color:#ff0000"> __store\,\,__ </span> |  | <span style="color:#ff0000"> __game__ </span> |  | content |  |
| <span style="color:#ff0000"> __game__ </span> |  | <span style="color:#ff0000"> __store__ </span> |  | content |  |
| <span style="color:#ff0000"> __game__ </span> |  | <span style="color:#ff0000"> __review__ </span> |  | content |  |
| <span style="color:#ff0000"> __game__ </span> | <span style="color:#ff0000"> __video__ </span> |  | <span style="color:#ff0000"> __game__ </span> | content |  |
| <span style="color:#ff0000"> __game__ </span> | <span style="color:#ff0000"> __video__ </span> |  | <span style="color:#ff0000"> __review__ </span> | content |  |

API para las queries

1\.1 	 _TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

_1\.3 	TermRangeQuery: busca por rangos_

_1\.4 _  <span style="color:#00b050"> _	_ </span>  _PhraseQuery: busca secuencia_

<span style="color:#00b050"> _1\.5 	 WildcardQuery: busca por matching de \* o bien ?_ </span>

1\.6 	FuzzyQuery: Damerau\-Levenshtein con MaxEdit 2

1\.7 	BooleanQuery

Etc\.\, etc\.\,  etc\.

| API | QueryParser |
| :-: | :-: |
| __queryStr__  __=__  __“g__  __??e__  __”__  __;__  __Term__  __ __  __myTerm__  __ = new __  __Term__  __\(__  __“__  __content__  __”__  __\, __ queryStr __\);__  __Query__  __ __  __query__  __= new __  __WildcardQuery__  __\(__  __myTerm__  __\);__ | queryStr=" __content:__  <span style="color:#ff0000"> __g__ </span>  <span style="color:#ff0000"> __??__ </span>  <span style="color:#ff0000"> __e__ </span> "; __Query__  __ __  __query__  __= __  __queryparser\.parse__  __\(__  __queryStr__  __\);__ |

Ejercicio 5\.5

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado

Donde los casos a probar son:

| Valor | FieldName | El query se esribe así |
| :-: | :-: | :-: |
| <span style="color:#ff0000"> __g\*e__ </span> | content |  |
| <span style="color:#ff0000"> __g?me__ </span> | content |  |
| <span style="color:#ff0000"> __g?m__ </span> | content |  |
| <span style="color:#ff0000"> __G??e__ </span> | content |  |
| <span style="color:#ff0000"> __\*__ </span> | content |  |

API para las queries

_1\.1 	TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

_1\.3 	TermRangeQuery: busca por rangos_

_1\.4 _  <span style="color:#00b050"> _	_ </span>  _PhraseQuery: busca secuencia_

_1\.5 	 WildcardQuery_

<span style="color:#00b050"> _1\.6 	FuzzyQuery: Damerau\-Levenshtein con MaxEdit 2_ </span>

1\.7 	BooleanQuery

Etc\.\, etc\.\,  etc\.

| API | QueryParser |
| :-: | :-: |
| __queryStr=__  __“g__  __no__  __”__  __;__  __Term myTerm = new Term\(__  __“content”__  __\, __ queryStr __\);__  __Query query= new FuzzyQuery\(myTerm\);__ | queryStr=" __content:__  <span style="color:#ff0000"> __gno~2__ </span> "; __Query__  __ __  __query__  __= __  __queryparser\.parse__  __\(__  __queryStr__  __\);__ |

Ejercicio 5\.6

Realizar los siguiente cambios\, re ejecutar  y explicar el resultado\.

__Y con distancia 1:__

| Valor | FieldName | El query se esribe así |
| :-: | :-: | :-: |
| <span style="color:#ff0000"> __gno__ </span> | content |  |
| <span style="color:#ff0000"> __agen__ </span> | content |  |
| <span style="color:#ff0000"> __agem__ </span> | content |  |
| <span style="color:#ff0000"> __hm__ </span> | content |  |
| <span style="color:#ff0000"> __ham__ </span> | content |  |

| Valor | FieldName | El query se esribe así |
| :-: | :-: | :-: |
| <span style="color:#ff0000"> __ham__ </span> | content |  |

API para las queries

_1\.1 	TermQuery: busca un solo término_

_1\.2 	PrefixQuery: busca por prefijo_

_1\.3 	TermRangeQuery: busca por rangos_

_1\.4 _  <span style="color:#00b050"> _	_ </span>  _PhraseQuery: busca secuencia_

_1\.5 	 WildcardQuery_

_1\.6 	_  __FuzzyQuery: Damerau\-Levenshtein con MaxEdit 2__

<span style="color:#00b050">1\.7 	BooleanQuery</span>

Etc\.\, etc\.\,  etc\.

Ejercicio 5\.7  \(tarea para el hogar\)

Buscar por cualquiera de estas 2 palabras:

Buscar por ambas palabras:

<span style="color:#000000">content:s</span>  <span style="color:#000000">tore  content:game</span>

<span style="color:#000000">content:store OR content: game</span>

<span style="color:#000000">content:store || content:game</span>

<span style="color:#000000">content:store</span>  <span style="color:#000000"> && </span>  <span style="color:#000000">content: game</span>

<span style="color:#000000">content:store AND content: game</span>

Ejercicio 5\.8

Son equivalentes estas expresiones?:

content:review OR \(content:game AND NOT content:yo\)

\(content:review OR content:game\) AND NOT content:yo

Explicar resultados

__Aclaración__

Si todas las query se hacen sobre el mismo fieldName puede especificarse una sola vez \(un default\)

En vez de :

__String__  __ __  __queryStr__  __= "__  <span style="color:#00b050"> __content__ </span>  __:game__  __ AND __  <span style="color:#00b050"> __content__ </span>  __:store__  __";__

__QueryParser__  __ __  __queryparser__  __ = new __  __QueryParser__  __\(__  __null__  __\, new __  __StandardAnalyzer__  __\(\) \);__

__Query__  __ __  __query__  __= __  __queryparser\.parse__  __\(__  __queryStr__  __\);__

Escribimos:

__String__  __ __  __queryStr__  __= "__  __game__  __ AND store";__

__QueryParser__  __ __  __queryparser__  __ = new __  __QueryParser__  __\("__  <span style="color:#00b050"> __content__ </span>  __"\, new __  __StandardAnalyzer__  __\(\) \);__

__Query__  __ __  __query__  __= __  __queryparser\.parse__  __\(__  __queryStr__  __\);__

