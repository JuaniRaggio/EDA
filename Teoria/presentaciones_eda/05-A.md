# Estructura de Datos y Algoritmos

# ITBA     2025-Q2

# String Matching – Q-Grams

__Q\-__  __Grams__  __ \(o N\-__  __Grams__  __\)__

Es un algoritmo que consiste en generar los pedazos que componen un string\. La distancia entre 2 strings estará dada por la cantidad componentes que tengan en común\.

Si  Q es 1 se generan componentes de longitud 1\, Si Q es 2 se generan bi\-gramas\, si Q es 3 se generan tri\-gramas\.

Por ejemplo\, para el string “JOHN” si se quiere generar hasta tri\-gramas \(Q <= 3\)\, puede completarse al comienzo y al final con Q\-1 símbolos especiales \(que no pertenezcan al alfabeto\) y deslizando la ventana imaginaria de tamaño Q\, se va generando los Q\-gramas\.  Sea ‘\#\#JOHN\#\#’:

Q\-grams \(John\) = \{  <span style="color:#d270aa">‘J’\, ‘O’\, ‘H’\, ‘N’</span> \,  <span style="color:#92d050">‘\#J’\, ‘JO’\, ‘OH’\, ‘HN’\, ‘N\#’</span> \,

<span style="color:#ffc000">‘\#\#J’\, ‘\#JO’\, ‘JOH’\, ‘OHN’\, ‘HN\#’\, ‘N\#\#’</span> \}

Q\-grams \(John\) = \{  <span style="color:#d270aa">‘J’\, ‘O’\, ‘H’\, ‘N’</span> \,  <span style="color:#92d050">‘\#J’\, ‘JO’\, ‘OH’\, ‘HN’\, ‘N\#’</span> \,

<span style="color:#ffc000">‘\#\#J’\, ‘\#JO’\, ‘JOH’\, ‘OHN’\, ‘HN\#’\, ‘N\#\#’</span> \}

Qué tan distinto es ‘JOHN’ de ‘JOE’ ? ¿Qué calculamos?

Q\-grams \(Joe\) = \{  <span style="color:#d270aa">‘J’\, ‘O’\, </span>  <span style="color:#d270aa">‘E’</span> \,  <span style="color:#92d050">‘\#J’\, ‘JO’\, ‘</span>  <span style="color:#92d050">OE’\, ‘E\#’</span> \,  <span style="color:#ffc000">‘\#\#J’\, ‘\#JO’\, ‘JOE’\, ‘OE\#’\, ‘E\#\#’ </span> \}

Los Q\-gramas que tienen en común son:

Distancia\(John\, Joe\) = 6

Como siempre\, se precisa alguna fórmula para pasarlo a un número \[0\, 1\]\. Existen varias formas de hacerlo\.

Variantes más sofisticadas existen\. Por ejemplo:  n sólo calculan los Q\-Gramas sino la posición que ocupan en el string\. Por lo tanto\, no es lo mismo que haya coincidencia exactamente en la misma posición a que coincidan pero en otro lugar\.

Ejemplo\,   Q\-Gram\(‘JOHN’\, ‘JOE’\) para Q=3\, sabiendo que

Q\-grams \(John\) =\{ <span style="color:#ffc000">‘\#\#</span>  <span style="color:#ffc000">J’\, ‘\#JO’\, ‘JOH’\, ‘OHN’\, ‘HN\#’\, ‘N\#\#’</span> \}

Q\-grams \(Joe\) = \{ <span style="color:#ffc000">‘\#\#J’\, ‘\#JO’\, ‘JOE’\, ‘OE\#’\, ‘E\#\#’ </span> \}

Y los Q\-gramas que tienen en común son:  <span style="color:#ffc000">‘\#\#J’\, ‘\#JO’</span>

Q\-Gram\(John\, Joe\) = \(6 \+ 5 –  7\) /  \(6 \+ 5 \) = 0\.3636

Notar que si tuvieran TODOS los Q\-grams en común \(matching exacto\) tendríamos   \( N \+ N –  0\)  /  \(N \+ N\)  = 1

_Q\-Gram de 2 _  _parámetros_  _ _  _da “_  _similitud_  _” entre 2 strings: 1 _  _es_  _ _  _máxima_  _ _  _similitud_  _\, 0 _  _es_  _ _  _nula_

Para Q exactamente 2:

¿Cúal es la similitud entre  _salesal_  y  _vale_  ?

Justificar el cálculo\.

Rta

Q\-grams\(salesal\)= \{ \#s\, sa\,  _al_ \,  _le_ \, es\, sa\, al\, l\#\)

Q\-grams\(vale\)= \{ \#v\, va\,  _al_ \,  _le_ \, e\#\}\.

En común 2  \(ojo con los repetidos\!\)\.

Q\-Gram\(salesal\, vale\) = \(8 \+ 5 –  9\) /  \(8 \+ 5 \) = 0\.3076

Para Q exactamente 2:

¿Cúal es la similitud entre  _salesal_  y  _alale_  ?

Justificar el cálculo\.

Rta Q\-grams\(salesal\)= \{ \#s\, sa\,  _al_ \,  _le_ \, es\, sa\,  _al_ \, l\#\)

Q\-grams\(alale\)= \{ \#a\,  _al_ \, la\,  _al_ \,  _le_ \, e\#\}\.

En común 3  \(ojo con los repetidos\!\)\.

Q\-Gram\(salesal\, alale\) = \(8 \+ 6 –  8\) /  \(8 \+ 6 \) = 0\.4285

Escribir una aplicación Java que calcule los Q\-grams para Q exactamente “N” de un string dado \(N genérico\)\.

Deberá contar con un método printTokens\(\) tal que por cada grama encontrado devuelva la cantidad de apariciones\.

También debe contar con el método similarity\(“”\, “”\)

que  devuelva la “similitud” entre 2 strings

# Caso de Uso:

QGram g= new Qgram\(2\);  // 1\, 2\, 3 \.etc

g\.printTokens\(“alal”\);

//   \#a  1

//   al   2

//   la   1

//   l\#   1

…

double  value= g\.similarity\("salesal“\, "alale“\);

System\.out\.println\(value\);  //

…

Implementar Q\-Grams paramétrico y testeos de unidad\.

# TP 2A- Ejer 10

![](img/05-A_0.png)

Cuando implementaron QGrams paramétrico:

QGram g= new Qgram\(2\);  // 1\, 2\, 3 \.etc

g\.printTokens\(“alal”\); 		// no importa el orden del output

//   \#a  1

//   al   2

//   la   1

//   l\#   1

…

double  value= g\.similarity\("salesal“\, "alale“\);

System\.out\.println\(value\);  //

…

Qué ventajas/desventajas tiene: implementación con ArrayList vs HashMap?

# Comparando algoritmos…

__Análisis de un caso extremo:__

Si quiero la similitud entre 2 frases \(por lo menos 2 palabras\)\, en qué tipo de frases resulta muchííísimo mejor Qgrams que Levenshtein/Metaphone/Soundex\.

Exhibir un caso\.

Resumiendo\,  los algoritmos representantes que hemos analizado sobre procesamiento de Strings

Dominio dependientes

