# Estructura de Datos y Algoritmos

# ITBA     2025-Q2

# Lucene



* <span style="color:#00b050"> _Concepto de documento\, campos\._ </span>
* <span style="color:#00b050"> _Almacenamiento en _ </span>  <span style="color:#00b050"> _Lucene_ </span>  <span style="color:#00b050"> _: en el índice y fuera del índice_ </span>
* <span style="color:#00b050"> _Aplicaciones_ </span>
  * <span style="color:#00b050"> _IndexBuilder_ </span>  <span style="color:#00b050"> _  \(creación de los documentos\)_ </span>
  * <span style="color:#00b050"> _TheSearcher_ </span>  <span style="color:#00b050"> _ \(búsqueda de documentos\)_ </span>
* <span style="color:#00b050"> _Query_ </span>  <span style="color:#00b050"> _:_ </span>
  * <span style="color:#00b050"> _API_ </span>
  * <span style="color:#00b050"> _QueryBuilder_ </span>
* <span style="color:#00b050"> _Formas de separar en _ </span>  <span style="color:#00b050"> _tokens_ </span>
* <span style="color:#00b050">Ranking de documentos</span>


Empecemos analizando cuál es la fórmula si la consulta está formada por  __un solo término__ \. Es decir:

Query= término

¿Cómo rankear a aquellos documentos que matchean con la consulta?

# Query de un término

Dada una colección de N documentos D= \{DOC1\, DOC2\, … DOCn\}  y una query=term\, para aquellos documentos que matchean la consulta:

<span style="color:#c00000">Score\(</span>  <span style="color:#c00000">DOC</span>  <span style="color:#c00000">i</span>  <span style="color:#c00000">\, </span>  <span style="color:#c00000">query</span>  <span style="color:#c00000">\) </span> =

<span style="color:#0070c0">FormulaLocal</span>  <span style="color:#0070c0">\(</span>  <span style="color:#0070c0">DOC</span>  <span style="color:#0070c0">i</span>  <span style="color:#0070c0">\,term</span>  <span style="color:#0070c0">\) \* </span>  <span style="color:#7030a0">FormulaGlobal</span>  <span style="color:#7030a0">\(D\, </span>  <span style="color:#7030a0">term</span> \)

__FormulaLocal__ : quiere calcular que tan relevante es esa query respecto a un documento en particular a rankear\.

¿Es lo mismo si el término aparece pocas veces en el documento que si aparece muchas veces? Intuitivamente si buscan un libro que explique sobre “algoritmos”\, es lo mismo si lo menciona 1 vez que si lo menciona 100 veces?

Por otro lado\, es lo mismo si el documento tiene pocos términos que si tiene más términos?

Intuitivamente\, ¿es lo mismo si un paper tiene una sola página \(ej: 200 términos en ella\) y lo menciona 100 veces que si tiene 500 páginas  \(ej: 100000 términos en ella\) y también lo menciona 100 veces?  El primero parece ser más específico\. O sea\, el tamaño del documento es importante\.

# TP 2-C Ejer 7

Query de un solo término\.

![](img/07-B%281%29_0.png)

# Query de un término

Calcular el ranking de documentos  cuando se busca por el término “game” en la colección de documentos formados por el field “content”

La colección es:

Docid 0  \(a\.txt\)

Game video\,

review    game\.

| Value term | Freq en docs | Docid:freqs in docid |  |
| :-: | :-: | :-: | :-: |
| game | 3 | 0 | 1 |
|  |  | 2 | 1 |
|  |  | 3 | 2 |
| review | 1 | 3 | 1 |
| store | 1 | 0 | 1 |
| video | 2 | 1 | 1 |
|  |  | 3 | 1 |

Docid 0  \(a\.txt\)

Game video\,

review    game\.

| Value term | Freq en docs | Docid:freqs in docid |  |
| :-: | :-: | :-: | :-: |
| game | 3 | 0 | 1 |
|  |  | 2 | 1 |
|  |  | 3 | 2 |
| review | 1 | 3 | 1 |
| store | 1 | 0 | 1 |
| video | 2 | 1 | 1 |
|  |  | 3 | 1 |

Docid 0  \(a\.txt\)

Ahora para aquellos documentos que matchearon la consulta calcular la FormulaLocal

Ahora sí usa la otra parte de la información indexada

![](img/07-B%281%29_1.png)

| Value term | Freq en docs | Docid:freqs in docid |  |
| :-: | :-: | :-: | :-: |
| game | 3 | 0 | 1 |
|  |  | 2 | 1 |
|  |  | 3 | 2 |
| review | 1 | 3 | 1 |
| store | 1 | 0 | 1 |
| video | 2 | 1 | 1 |
|  |  | 3 | 1 |

Docid 0  \(a\.txt\)

Game video\,

review    game\.

| Value term | Freq en docs | Docid:freqs in docid |  |
| :-: | :-: | :-: | :-: |
| game | 3 | 0 | 1 |
|  |  | 2 | 1 |
|  |  | 3 | 2 |
| review | 1 | 3 | 1 |
| store | 1 | 0 | 1 |
| video | 2 | 1 | 1 |
|  |  | 3 | 1 |

Docid 0  \(a\.txt\)

Docid 0  \(a\.txt\)

| Value term | Freq en docs | Docid:freqs in docid |  |
| :-: | :-: | :-: | :-: |
| game | 3 | 0 | 1 |
|  |  | 2 | 1 |
|  |  | 3 | 2 |
| review | 1 | 3 | 1 |
| store | 1 | 0 | 1 |
| video | 2 | 1 | 1 |
|  |  | 3 | 1 |

Docid 0  \(a\.txt\)

Docid 0  \(a\.txt\)

Score\(DOC2\,query\)  __= 1 \* __  <span style="color:#7030a0">1\.2231436</span>  =  <span style="color:#0070c0"> __1\.2231436__ </span>  <span style="color:#0070c0"> __ __ </span>

| Value term | Freq en docs | Docid:freqs in docid |  |
| :-: | :-: | :-: | :-: |
| game | 3 | 0 | 1 |
|  |  | 2 | 1 |
|  |  | 3 | 2 |
| review | 1 | 3 | 1 |
| store | 1 | 0 | 1 |
| video | 2 | 1 | 1 |
|  |  | 3 | 1 |

Docid 0  \(a\.txt\)

Docid 0  \(a\.txt\)

Dado que tenemos:

Score\(DOC0\,query\)  __= __  <span style="color:#0070c0"> __0\.8648931__ </span>

Score\(DOC2\,query\)  __= __  <span style="color:#0070c0"> __1\.2231436__ </span>

Score\(DOC3\,query\)  __= __  <span style="color:#0070c0"> __0\.8648931__ </span>

<span style="color:#0070c0"> __O sea\, aparecen ordenados descendentemente por score:__ </span>

<span style="color:#0070c0"> __Doc2__ </span>

<span style="color:#0070c0"> __Doc0    __ </span>

<span style="color:#0070c0"> __Doc3__ </span>  <span style="color:#0070c0"> __ __ </span>

# Query de un término modificado por fórmula

Si tenemos que el query usa un solo término modificado por FuzzySearch\, Range\, Prefix\, Wildcard : se devuelve como score 1 a los documentos que matchean

<span style="color:#0070c0"> __Ej__ </span>  <span style="color:#0070c0"> __: __ </span>  <span style="color:#0070c0"> __query__ </span>  <span style="color:#0070c0"> __=__ </span>  <span style="color:#0070c0"> __ga__ </span>  <span style="color:#0070c0"> __\*  sobre los mismos __ </span>  <span style="color:#0070c0"> __docs__ </span>

Dado que tenemos:

Score\(DOC0\,query\)  __= __  <span style="color:#0070c0"> __1__ </span>

Score\(DOC2\,query\)  __= __  <span style="color:#0070c0"> __1__ </span>

Score\(DOC3\,query\)  __= __  <span style="color:#0070c0"> __1__ </span>

<span style="color:#0070c0"> __O sea\, aparecen __ </span>  <span style="color:#0070c0"> __los 3 __ </span>  <span style="color:#0070c0"> __matching__ </span>  <span style="color:#0070c0"> __ \(el score no sirve para ordenar\)__ </span>

<span style="color:#0070c0"> __Doc0__ </span>

<span style="color:#0070c0"> __Doc2    __ </span>

<span style="color:#0070c0"> __Doc3__ </span>  <span style="color:#0070c0"> __ __ </span>

# Query Multi-término

# TP 2-C Ejer 8

Query multi término\.

![](img/07-B%281%29_2.png)

# Query Multi-término

Calcular el ranking de documentos  cuando se busca por el término “game AND NOT store” en la colección de documentos formados por el field “content”\. La colección es la misma:

Docid 0  \(a\.txt\)

Game video\,

review    game\.

Rta

¿Cuáles son los documentos que matchean la query?

Docid 0  \(a\.txt\)

Game video\,

review    game\.

El score debido al término “game” ya lo hemos calculado\.

El score debido al término “store” no aplica a la fórmula de score porque está afectado por NOT\. Obtendremos para esos 2 documentos los valores de score anteriores\.

Score\(DOC2\,query\)  __= __  <span style="color:#0070c0"> __1\.2231436__ </span>

Score\(DOC3\,query\)  __= __  <span style="color:#0070c0"> __0\.8648931__ </span>

Y en el resultado primero aparece Doc2 y luego Doc3

Calcular el ranking de documentos  cuando se busca por el término “game AND store” en la colección de documentos formados por el field “content”\. La colección es la misma:

Docid 0  \(a\.txt\)

Game video\,

review    game\.

Rta

¿Cuáles son los documentos que matchean la query?

Docid 0  \(a\.txt\)

Game video\,

review    game\.

Ya habíamos calculado el caso “game”\. Ahora falta el caso “store”

| Value term | Freq en docs | Docid:freqs in docid |  |
| :-: | :-: | :-: | :-: |
| game | 3 | 0 | 1 |
|  |  | 2 | 1 |
|  |  | 3 | 2 |
| review | 1 | 3 | 1 |
| store | 1 | 0 | 1 |
| video | 2 | 1 | 1 |
|  |  | 3 | 1 |

| Value term | Freq en docs | Docid:freqs in docid |  |
| :-: | :-: | :-: | :-: |
| game | 3 | 0 | 1 |
|  |  | 2 | 1 |
|  |  | 3 | 2 |
| review | 1 | 3 | 1 |
| store | 1 | 0 | 1 |
| video | 2 | 1 | 1 |
|  |  | 3 | 1 |

# Query de Muti-término

Docid 0  \(a\.txt\)

Docid 0  \(a\.txt\)

Finalmente

Score\(DOC0\,”game AND store”\)=  <span style="color:#0070c0"> __0\.8648931 \+  __ </span>  <span style="color:#0070c0"> __1\.3550219__ </span>

__=  __ 2\,219915

Calcular el ranking de documentos  cuando se busca por el término “game OR store” en la colección de documentos formados por el field “content”

La colección es la misma:

Docid 0  \(a\.txt\)

Game video\,

review    game\.

Rta

¿Cuáles son los documentos que matchean la query?

Docid 0  \(a\.txt\)

Game video\,

review    game\.

El calculo de FormulaGlobal\(DOC\,”store”\)  __= __  <span style="color:#7030a0">1\.9162907  YA LO TENIAMOS</span>

<span style="color:#7030a0">Falta calcular </span>  <span style="color:#7030a0">FormulaLocal</span>  <span style="color:#7030a0"> para los nuevos </span>  <span style="color:#7030a0">docs</span>  <span style="color:#7030a0"> \(para doc0 ya lo teníamos\)</span>

<span style="color:#7030a0">Como en doc3 y doc2 no estaba “store”\, </span>

FormulaLocal\(DOC3\,”store”\)= 0

FormulaLocal\(DOC2\,”store”\)= 0

<span style="color:#7030a0">Pero la parte de “</span>  <span style="color:#7030a0">game</span>  <span style="color:#7030a0">” si les da score \(el que calculamos previamente\)</span>

Finalmente

Score\(DOC0\,”game OR store”\)=  <span style="color:#0070c0"> __0\.8648931 \+  1\.3550219 __ </span>  __=  __ 2\,219915

Score\(DOC2\,”game OR store”\)=  <span style="color:#0070c0"> __1\.2231436 __ </span>  <span style="color:#0070c0"> __\+  __ </span>  <span style="color:#0070c0"> __0 __ </span>  __= __  __1\.2231436__

Score\(DOC3\,”game OR store”\)=  <span style="color:#0070c0"> __0\.8648931 \+  __ </span>  <span style="color:#0070c0"> __0 __ </span>  __= __  __0\.8648931__

__Y __  __Rankean__  __:__

__Doc0__

__Doc2__

__Doc3__

__Consideraciones__

Lucene es un excelente implementación para Fulltext Retrieval\.

Permite que lo extendamos\. Ej: podemos hacer una Analyzer que maneje Metaphone para ofrecer búsqueda fonética\.

__Lucene__  no ofrece escalabilidad\. A medida que el conjunto de documentos crece o los clientes que realizan consultas crece\, eso puede ser un problema\.

Si se precisa un backend que permita escalabilidad\, debemos usar   __Solr__  o  __Elasticsearch__ \. Ambos frameworks están construidos sobre Lucene pero permiten escalar ya que coordinan varias instancias de Lucene\, las cuales pueden correr en diferentes computadoras \(en un cluster de computadoras\)\.

![](img/07-B%281%29_3.jpg)

![](img/07-B%281%29_4.jpg)

Index lucene: doc1\, doc2\, doc3\, doc4\, doc5\, doc6

Docs:

Doc1\, doc2\, doc3\, do4\, doc5\, doc6

Solr / Elasticsearch

![](img/07-B%281%29_5.jpg)

![](img/07-B%281%29_6.jpg)

![](img/07-B%281%29_7.jpg)

![](img/07-B%281%29_8.jpg)

![](img/07-B%281%29_9.jpg)

Index lucene id1\, id4

Index lucene id3\, id6

Index lucene

Id2\, id5

