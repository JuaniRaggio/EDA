# Estructura de Datos y Algoritmos

# ITBA     2025-Q2

__Como ejecuto desde __  __linea__  __ de comando el __  __Timer__  __FromScratch__  __ \(__  __version__  __ __  __maven__  __\)?__

Ejecutar desde línea de comandos el main de la clase dentro de   TimerFromScrach versión Maven\.

Ej: el jar me quedo aca:

<span style="color:#00b050">C:\\Users\\lgomez\\\.</span>  <span style="color:#00b050">m2\\repository\\ar\\edu\\itba\\eda\\TimerFromScratch\\1\\TimerFromScratch\-1\.jar</span>

Abro terminal \(cmd\, xterm\, etc\)

java \-cp c <span style="color:#00b050">:\\</span>  <span style="color:#00b050">Users\\lgomez\\\.m2\\repository\\ar\\edu\\itba\\eda\\TimerFromScratch\\1\\TimerFromScratch\-1\.jar </span>  <span style="color:#00b050">   </span>  <span style="color:#0070c0">core\.MyTimer</span>

![](img/02-A%281%29_0.png)

__Agregar un nuevo __  __plugin__  __ y ver qué __  __genera__

__En el __  __timer__  __ __  __from__  __ __  __scratch__

# TP 1-Ejer 3.2

__Desde el directorio del proyecto donde se encuentra el pom\.xml__

<plugin>

<groupId>org\.apache\.maven\.plugins</groupId>

<artifactId>maven\-jar\-plugin</artifactId>

<version>3\.4\.2</version>

<configuration>

\<archive>

<manifest>

<mainClass> <span style="color:#ff0000">MyPackage\.TheClass</span> </mainClass>

</manifest>

\</archive>

</configuration>

</plugin>

<span style="color:#cc0000"> __Nombre Java de la clase __ </span>

<span style="color:#cc0000"> __con todos sus __ </span>  <span style="color:#cc0000"> __packages__ </span>

Ejecutar desde línea de comandos usando el comando “jar”

Abro terminal \(cmd\, xterm\, etc\)

java \-cp c <span style="color:#00b050">:\\</span>  <span style="color:#00b050">Users\\lgomez\\\.</span>  <span style="color:#00b050">m2\\repository\\ar\\edu\\itba\\eda\\TimerFromScratch\\1\\TimerFromScratch\-1\.jar    </span>  <span style="color:#0070c0">core\.MyTimer</span>

java \-jar c <span style="color:#00b050">:\\Users\\lgomez\\\.</span>  <span style="color:#00b050">m2\\repository\\ar\\edu\\itba\\eda\\TimerFromScratch\\1\\TimerFromScratch\-1\.jar</span>

![](img/02-A%281%29_1.png)

# TP 1- Ejer 5.1 y 5.2

Crear un nuevo proyecto Maven  __AnalysisTime__

__Vamos a usar nuestra  biblioteca hecha __  __TimerJoda__  __:__

__Asegurarse que __  __TimerJoda__  __ fue instalada en el repositorio local__

![](img/02-A%281%29_2.png)

Armar un nuevo proyecto mvn llamado  __AnalysisTime__   que use a la biblioteca    __TimerJoda__ \, pero NO DECLARE a Joda Time en el pom\.xml

Es decir\, en este proyecto colocar solo:

package main;

…

__	__  __public__  __ __  __class__  __ __  __Proof__  __\{__

__		public __  __static void main\(String\[\] __  __args__  __\) \{__

Timer myCrono =  __new __  __Timer__  __\(10\);__

myCrono\.stop\(10 \+ 93623040\);

System\. _out\.println_  _\(_  _myCrono_  _\);_

\}

\}

¿Cómo se declara TimerJoda \(la nuestra\) en este pom\.xml?

Debe poder instalarse \(compilar correctamente\)\.

¿Ejecuta correctamente? Qué bibliotecas está usando? Como se resolvió?

# TP 1- Ejer 5.3, 5.4 y 5.5

Tiene  __AnalysisTime\.jar  dentro las 2 bibliotecas que sabemos usa?__

Imaginemos que le entregamos AnalysisTime\.jar a un cliente\.

__No podemos esperar que las bibliotecas __  __TimerJoda__  __ y Joda Time \(usada indirectamente\) estén en su computadora\.__

__¿__  __Cómo resolver esta situación?__

![](img/02-A%281%29_3.png)

Si desde línea de comandos usamos  \(parados en cualquier lado\)

__$ __  __java  __  <span style="color:#ff0000"> __\-__ </span>  <span style="color:#ff0000"> __cp__ </span>  <span style="color:#ff0000"> __  __ </span>  __c:\\Users\\lgomez\\\.__  __m2\\repository\\ar\\edu\\itba\\eda\\AnalysisTime\\1\\AnalysisTime\-1\.jar   __  <span style="color:#ff0000"> __Proof__ </span>  __	__

¿Qué sucede?

![](img/02-A%281%29_4.png)

Si se quiere incluir en nuestro jar\, otras bibliotecas que usar directa/indirectamente usamos otro mvn plugin\. Regenerar mvn install

<plugin>

<groupId>org\.apache\.maven\.plugins</groupId>

<artifactId>maven\-assembly\-plugin</artifactId>

<version>3\.6\.0</version>

<executions>

\<execution>

<phase>package\</phase>

<goals>

<goal>single\</goal>

</goals>

\<configuration>

<descriptorRefs>

<span style="color:#0070c0"><</span>  <span style="color:#0070c0">descriptorRef</span>  <span style="color:#0070c0">>jar\-with\-dependencies</</span>  <span style="color:#0070c0">descriptorRef</span>  <span style="color:#0070c0">></span>

</descriptorRefs>

\</configuration>

</execution>

</executions>

</plugin>

# TP 1- Ejer 5.6

![](img/02-A%281%29_5.png)

Intentar ejecutar desde línea de comandos el archivo jar\.

__$ java __  <span style="color:#ff0000"> __–__ </span>  <span style="color:#ff0000"> __cp__ </span>  <span style="color:#ff0000"> __ __ </span>  __c__  __:\\Users\\lgomez\\\.__  __m2\\repository\\ar\\edu\\itba\\eda\\AnalysisTime\\1\\__  __AnalysisTime\-1\-jar\-with\-dependencies\.jar  __  <span style="color:#ff0000"> __Proof__ </span>

Si bien funciona OK\, es engorroso pedirle al usuario que indique la clase que contiene el main\.

Si ejecutamos sin indicar “Proof”

__$ __  __java __  <span style="color:#ff0000"> __–jar __ </span>  __c:\\Users\\lgomez\\\.m2\\repository\\ar\\edu\\itba\\eda\\AnalysisTime\\1\\AnalysisTime\-1\-jar\-with\-dependencies\.jar __

No funciona\.

# Agregar al pom  “mainClass”:  package.nombreClass

Si se quiere incluir en nuestro jar\, otras bibliotecas que usar directa/indirectamente usamos otro mvn plugin\. Regenerar mvn install

<plugin>

<groupId>org\.apache\.maven\.plugins</groupId>

<artifactId>maven\-assembly\-plugin</artifactId>

<version>3\.3\.0</version>

<executions>

\<execution>

<phase>package\</phase>

<goals>

<goal>single\</goal>

</goals>

\<configuration>

<descriptorRefs>

<descriptorRef>jar\-with\-dependencies</descriptorRef>

</descriptorRefs>

\</configuration>

</execution>

</executions>

</plugin>

<span style="color:#000000"><</span>  <span style="color:#268bd2">archive</span>  <span style="color:#000000">></span>

<span style="color:#000000">   <</span>  <span style="color:#268bd2">manifest</span>  <span style="color:#000000">></span>

<span style="color:#000000">       <</span>  <span style="color:#268bd2">mainClass</span>  <span style="color:#000000">></span>  <span style="color:#ff0000">main\.Proof</span>  <span style="color:#000000"></</span>  <span style="color:#268bd2">mainClass</span>  <span style="color:#000000">></span>

<span style="color:#000000">   </</span>  <span style="color:#268bd2">manifest</span>  <span style="color:#000000">></span>

<span style="color:#000000"></</span>  <span style="color:#268bd2">archive</span>  <span style="color:#000000">></span>

¿Ejecuta el jar con dependencias ahora sin indicar la clase principal?

D:\\ECD>java  <span style="color:#0070c0">\-</span>  <span style="color:#0070c0">jar</span>  <span style="color:#0070c0"> </span> C:\\Users\\lgomez\\\.m2\\repository\\ar\\edu\\itba\\eda\\AnalysisTime\\1\\AnalysisTime\-1\-jar\-with\-dependencies\.jar

Explicar por qué anda OK\.

Abrir el jar que generó\. ¿Qué tiene el archivo Mainfest\.mf?

![](img/02-A%281%29_6.png)

# Actualmente, existe otra implementación del Timer: Java 8 (nativo) también agregó una biblioteca para manejo de timers

# TP 1- Ejer 6

A partir de Java 8\, java agregó un manejo para Timers…

Armar un nuevo proyecto maven para usar dicha API\.

Nuestra versión 3 será un wrapper sobre la misma\.

![](img/02-A%281%29_7.png)

<groupId>ar\.edu\.itba\.eda</groupId>   <artifactId>TimerNativo</artifactId>

__<__  __version__  __>3</__  __version__  __>__

Y agregar en el pom lo necesario para que pueda empaquetarse\, etc\.

Investigar las clases Instant y Duration

Implementar nuestra versión usando dicha biblioteca\.



* ¿ Cómo estar seguros de que funciona realmente correctamente las 3 implementaciones?
* ¿ Cómo asegurarnos que cuando implementemos nuevos algoritmos\, sigue funcionando correctamente?
